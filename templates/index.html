<!DOCTYPE html>
<html>
<head>
    <title>Neural Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            background-color: #1e1e1e;
            color: #f0f0f0;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
        }
        
        #filters {
            width: 300px;
            padding: 20px;
            background: #2a2a2a;
            overflow-y: auto;
        }
        
        #visualization {
            flex-grow: 1;
            position: relative;
            background: #1e1e1e;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
        }
        
        .node text {
            fill: #fff;
            font-size: 12px;
        }
        
        .filter-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 1px solid #404040;
        }
        
        .tab-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: none;
            color: #f0f0f0;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: background 0.3s;
        }
        
        .tab-button.active {
            background: #D35400;
        }
        
        .filter-section {
            padding: 10px 0;
            display: none;
        }
        
        .filter-section.active {
            display: block;
        }
        
        .filter-group {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .filter-group-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .filter-btn {
            padding: 4px 10px;
            border: 1px solid #404040;
            border-radius: 15px;
            background: transparent;
            color: #f0f0f0;
            cursor: pointer;
            margin: 2px;
            transition: all 0.2s;
        }
        
        .filter-btn:hover {
            background: #404040;
        }
        
        .filter-btn.active {
            background: #D35400;
            border-color: #D35400;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="filters">
        <!-- Your existing filter HTML here -->
    </div>
    
    <div id="visualization"></div>

    <script>
        class GraphVisualization {
            constructor() {
                this.width = document.getElementById('visualization').clientWidth;
                this.height = document.getElementById('visualization').clientHeight;
                this.simulation = null;
                this.svg = null;
                this.link = null;
                this.node = null;
                this.tooltip = null;
                
                this.initializeSVG();
                this.initializeSimulation();
                window.addEventListener('resize', () => this.handleResize());
            }
            
            initializeSVG() {
                this.svg = d3.select('#visualization')
                    .append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height);
                    
                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.svg.select('g').attr('transform', event.transform);
                    });
                    
                this.svg.call(zoom);
                
                // Add a group for the graph elements
                this.svg = this.svg.append('g');
                
                // Initialize tooltip
                this.tooltip = d3.select('#visualization')
                    .append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);
            }
            
            initializeSimulation() {
                this.simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id))
                    .force('charge', d3.forceManyBody().strength(-100))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide().radius(30));
            }
            
            updateGraph(data) {
                // Clear existing elements
                this.svg.selectAll('*').remove();
                
                // Create the graph elements
                this.link = this.svg.append('g')
                    .selectAll('line')
                    .data(data.relationships)
                    .enter().append('line')
                    .attr('class', 'link');
                    
                this.node = this.svg.append('g')
                    .selectAll('g')
                    .data(data.nodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragstarted(event, d))
                        .on('drag', (event, d) => this.dragged(event, d))
                        .on('end', (event, d) => this.dragended(event, d)));
                        
                // Add circles for nodes
                this.node.append('circle')
                    .attr('r', 10)
                    .style('fill', d => this.getNodeColor(d.labels[0]));
                    
                // Add labels
                this.node.append('text')
                    .attr('dx', 12)
                    .attr('dy', '.35em')
                    .text(d => d.properties.name || d.labels[0]);
                    
                // Add hover interactions
                this.node
                    .on('mouseover', (event, d) => this.showTooltip(event, d))
                    .on('mouseout', () => this.hideTooltip());
                    
                // Update simulation
                this.simulation
                    .nodes(data.nodes)
                    .on('tick', () => this.ticked());
                    
                this.simulation.force('link')
                    .links(data.relationships);
                    
                // Restart simulation
                this.simulation.alpha(1).restart();
            }
            
            ticked() {
                this.link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                    
                this.node
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            }
            
            dragstarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            dragended(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            showTooltip(event, d) {
                const properties = Object.entries(d.properties)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join('<br>');
                    
                this.tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                this.tooltip.html(`Type: ${d.labels.join(', ')}<br>${properties}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            }
            
            hideTooltip() {
                this.tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            }
            
            getNodeColor(label) {
                const colors = {
                    'nerve': '#ff7f0e',
                    'bone': '#2ca02c',
                    'neuro': '#d62728',
                    'region': '#9467bd',
                    'viscera': '#8c564b',
                    'muscle': '#e377c2',
                    'sense': '#7f7f7f',
                    'vein': '#bcbd22',
                    'artery': '#17becf',
                    'cv': '#1f77b4',
                    'function': '#ff9896',
                    'sensory': '#98df8a',
                    'gland': '#c5b0d5',
                    'lymph': '#c49c94',
                    'head': '#f7b6d2',
                    'organ': '#c7c7c7',
                    'sensation': '#dbdb8d',
                    'skin': '#9edae5'
                };
                return colors[label.toLowerCase()] || '#666';
            }
            
            handleResize() {
                this.width = document.getElementById('visualization').clientWidth;
                this.height = document.getElementById('visualization').clientHeight;
                
                d3.select('#visualization svg')
                    .attr('width', this.width)
                    .attr('height', this.height);
                    
                this.simulation.force('center', d3.forceCenter(this.width / 2, this.height / 2));
                this.simulation.alpha(1).restart();
            }
        }

        // Initialize the visualization and filter manager
        const visualization = new GraphVisualization();
        const filterManager = new FilterManager();

        // Update the FilterManager's updateVisualization method
        FilterManager.prototype.updateVisualization = function() {
            const filters = {
                nodeTypes: Array.from(this.activeNodeTypes),
                locations: Array.from(this.activeSublocations)
            };
            
            // Fetch filtered graph data
            const queryParams = new URLSearchParams();
            filters.nodeTypes.forEach(type => queryParams.append('nodeTypes[]', type));
            filters.locations.forEach(location => queryParams.append('locations[]', location));
            
            fetch('/api/graph/filtered?' + queryParams.toString())
                .then(response => response.json())
                .then(data => visualization.updateGraph(data))
                .catch(error => console.error('Error fetching graph data:', error));
        };
    </script>
</body>
</html>
