<!DOCTYPE html>
<html>
<head>
    <title>Neo4j Force Graph</title>
    <link rel="stylesheet" type="text/css" href="/static/css/styles.css">
    <script src="https://unpkg.com/neo4j-driver"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Add your CSS styles here */
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 250px;
            padding: 20px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
        }
        .graph-container {
            flex-grow: 1;
            padding: 20px;
        }
        .filter-group {
            margin-bottom: 20px;
        }
        .filter-group h3 {
            margin-bottom: 10px;
        }
        .toggle-btn {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }
        .toggle-btn.active {
            background: #007bff;
            color: white;
        }
        #search-box {
            width: 90%;
            padding: 8px;
            margin-bottom: 10px;
        }
        #add-node-btn {
            width: 90%;
            padding: 8px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <input type="text" id="search-box" placeholder="Search nodes...">
            <button id="add-node-btn">Add Node</button>
            
            <div class="filter-group">
                <h3>Locations</h3>
                <div id="location-filters"></div>
            </div>
            
            <div class="filter-group">
                <h3>Node Types</h3>
                <div id="type-filters"></div>
            </div>
            
            <div class="filter-group">
                <h3>Relationships</h3>
                <div id="relationship-filters"></div>
            </div>
        </div>
        <div class="graph-container">
            <svg id="graph"></svg>
        </div>
    </div>

    <script>
    // Initialize empty graph
    let nodes = [];
    let links = [];
    let simulation;
    let svg = d3.select("#graph")
        .attr("width", "100%")
        .attr("height", "100%");
    
    // Filter states
    let activeFilters = {
        locations: new Set(),
        types: new Set(),
        relationships: new Set()
    };

    // Initialize the force simulation
    function initializeSimulation() {
        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(
                svg.node().getBoundingClientRect().width / 2,
                svg.node().getBoundingClientRect().height / 2
            ));
    }

    // Update the graph visualization
    function updateGraph() {
        // Links
        let link = svg.selectAll(".link")
            .data(links)
            .join("line")
            .attr("class", "link")
            .style("stroke", "#999")
            .style("stroke-width", 1);

        // Nodes
        let node = svg.selectAll(".node")
            .data(nodes)
            .join("circle")
            .attr("class", "node")
            .attr("r", 5)
            .style("fill", d => getNodeColor(d.type));

        // Node labels
        let label = svg.selectAll(".label")
            .data(nodes)
            .join("text")
            .attr("class", "label")
            .text(d => d.name)
            .attr("font-size", "12px")
            .attr("dx", 8)
            .attr("dy", 3);

        simulation.nodes(nodes).on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        simulation.force("link").links(links);
        simulation.alpha(1).restart();
    }

    // Color mapping for node types
    function getNodeColor(type) {
        const colors = {
            nerve: "#ff7f0e",
            artery: "#d62728",
            vein: "#1f77b4",
            muscle: "#2ca02c",
            organ: "#9467bd",
            bone: "#8c564b"
        };
        return colors[type] || "#aaa";
    }

    // Initialize the visualization
    initializeSimulation();
    updateGraph();

    // Add event listener for the Add Node button
    document.getElementById("add-node-btn").onclick = () => {
        const searchTerm = document.getElementById("search-box").value;
        if (searchTerm) {
            queryNeo4j(searchTerm);
        }
    };

    // Function to create toggle buttons
    function createToggleButtons(data, containerId) {
        const container = document.getElementById(containerId);
        data.forEach(item => {
            const button = document.createElement('button');
            button.className = 'toggle-btn';
            button.textContent = item;
            button.onclick = function() {
                this.classList.toggle('active');
                updateFilters();
            };
            container.appendChild(button);
        });
    }

    // Initialize filter buttons
    const filterData = {
        locations: ["neck", "thorax", "pelvis", "head", "lower limb", "upper limb", "spine", "abdomen", "other"],
        nodeTypes: ["artery", "muscle", "nerve", "organ", "vein", "viscera", "bone", "gland", "cv", "lymph", "sense", "sensation", "sensory", "function", "region", "neuro", "skin", "head"],
        relationships: ["drains_into", "includes", "perfuses", "innervates", "dorsal_column", "spinal_cord", "ant_spinothalamic", "lat_spinothalamic", "controls", "branches", "lymph_drains", "supplies_blood", "nerve_branches", "motor_innervation", "more_details", "exits_or_occupies", "spinothalamic_tract", "csf_flow", "pumps_blood", "releases_hormones", "sensory_input", "spinothalamic_decussation", "pyramidal_decussation", "corticospinal_termination"]
    };
    createToggleButtons(filterData.locations, 'location-filters');
    createToggleButtons(filterData.nodeTypes, 'type-filters');
    createToggleButtons(filterData.relationships, 'relationship-filters');

    // Function to query Neo4j and add nodes
    async function queryNeo4j(searchTerm) {
        const query = `
            MATCH (n)
            WHERE n.name =~ $searchTerm
            RETURN n.name as name, labels(n)[0] as type, n.location as location
            LIMIT 5
        `;
        
        // Here you would make an API call to your backend
        // For now, we'll simulate with some example data
        const results = [
            { name: searchTerm + " (example)", type: "nerve", location: "head" }
        ];
        
        results.forEach(result => {
            if (!nodes.some(n => n.id === result.name)) {
                nodes.push({
                    id: result.name,
                    name: result.name,
                    type: result.type,
                    location: result.location
                });
                updateGraph();
            }
        });
    }

    // Function to update filters
    function updateFilters() {
        // Update active filters based on button states
        activeFilters.locations = new Set([...document.querySelectorAll('#location-filters .toggle-btn.active')].map(btn => btn.textContent));
        activeFilters.types = new Set([...document.querySelectorAll('#type-filters .toggle-btn.active')].map(btn => btn.textContent));
        activeFilters.relationships = new Set([...document.querySelectorAll('#relationship-filters .toggle-btn.active')].map(btn => btn.textContent));
        
        // Call the filterNodes function with the active filters
        filterNodes([...activeFilters.types], [...activeFilters.locations], null, [...activeFilters.relationships]);
    }

    // Function to filter nodes
    async function filterNodes(labels, locations, sublocation, relationships) {
        try {
            const label = labels.join(',');
            const location = locations.join(',');
            const relationship = relationships.join(',');
            const response = await fetch(`/api/filter?label=${label}&location=${location}&sublocation=${sublocation}&relationship=${relationship}`);
            const data = await response.json();
            if (response.ok) {
                console.log('Filtered Results:', data);
                // Handle the filtered results (e.g., update the graph)
            } else {
                console.error('Error:', data.error);
            }
        } catch (error) {
            console.error('Fetch error:', error);
        }
    }

    </script>
</body>
</html>