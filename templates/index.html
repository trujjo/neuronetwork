<!DOCTYPE html>
<html>
<head>
    <title>Neuroanatomy Graph Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 250px;
            padding: 20px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
        }
        .graph-container {
            flex-grow: 1;
            padding: 20px;
            overflow: hidden;
        }
        .filter-group {
            margin-bottom: 20px;
        }
        .filter-group h3 {
            margin-bottom: 10px;
        }
        .toggle-btn {
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: inline-block;
        }
        .toggle-btn.active {
            background: #007bff;
            color: white;
        }
        #search-box {
            width: 90%;
            padding: 8px;
            margin-bottom: 10px;
        }
        .node-label {
            font-size: 10px;
            pointer-events: none;
        }
        .node-details {
            position: fixed;
            right: 20px;
            top: 20px;
            background: white;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <input type="text" id="search-box" placeholder="Search nodes...">
            
            <div class="filter-group">
                <h3>Node Types</h3>
                <div id="node-type-filters"></div>
            </div>
            
            <div class="filter-group">
                <h3>Relationships</h3>
                <div id="relationship-filters"></div>
            </div>
        </div>
        
        <div class="graph-container">
            <svg id="graph"></svg>
        </div>
        
        <div class="node-details" id="node-details">
            <h3>Node Details</h3>
            <div id="node-details-content"></div>
        </div>
    </div>

    <script>
        // Configuration
        const baseUrl = 'http://localhost:5000';
        const width = window.innerWidth - 290;
        const height = window.innerHeight;

        // Initialize D3.js force simulation
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // Create SVG container
        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // Initialize data structures
        let nodes = [];
        let links = [];
        let nodeTypes = new Set();
        let relationshipTypes = new Set();
        let activeFilters = {
            nodeTypes: new Set(),
            relationships: new Set()
        };

        // Color scale for different node types
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // Function to get metadata and initialize filters
        async function initializeFilters() {
            try {
                const response = await fetch(`${baseUrl}/api/metadata`);
                const data = await response.json();
                
                if (response.ok) {
                    createFilterButtons('node-type-filters', data.labels, 'nodeTypes');
                    createFilterButtons('relationship-filters', data.relationshipTypes, 'relationships');
                }
            } catch (error) {
                console.error('Failed to fetch metadata:', error);
            }
        }

        // Function to update the graph visualization
        function updateGraph() {
            // Clear existing elements
            svg.selectAll("*").remove();

            // Create arrow marker for directed edges
            svg.append("defs").selectAll("marker")
                .data(["end"])
                .enter().append("marker")
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5");

            // Draw links
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .attr("marker-end", "url(#end)");

            // Draw nodes
            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", 8)
                .attr("fill", d => color(d.labels[0]))
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", showNodeDetails)
                .on("mouseout", hideNodeDetails);

            // Add node labels
            const label = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("class", "node-label")
                .text(d => d.properties.name || d.labels[0])
                .attr("dx", 12)
                .attr("dy", 4);

            // Update simulation
            simulation
                .nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);

            // Tick function to update positions
            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            }
        }

        // Function to show node details
        function showNodeDetails(event, d) {
            const detailsDiv = document.getElementById("node-details");
            const content = document.getElementById("node-details-content");
            
            // Create HTML content for node details
            let html = `<p><strong>Labels:</strong> ${d.labels.join(", ")}</p>`;
            html += "<p><strong>Properties:</strong></p><ul>";
            for (const [key, value] of Object.entries(d.properties)) {
                html += `<li>${key}: ${value}</li>`;
            }
            html += "</ul>";
            
            content.innerHTML = html;
            detailsDiv.style.display = "block";
        }

        // Function to hide node details
        function hideNodeDetails() {
            document.getElementById("node-details").style.display = "none";
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Function to create filter buttons
        function createFilterButtons(containerId, items, filterType) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            items.forEach(item => {
                const button = document.createElement('button');
                button.textContent = item;
                button.className = 'toggle-btn';
                button.onclick = () => {
                    button.classList.toggle('active');
                    if (button.classList.contains('active')) {
                        activeFilters[filterType].add(item);
                    } else {
                        activeFilters[filterType].delete(item);
                    }
                    updateFilters();
                };
                container.appendChild(button);
            });
        }

        // Search functionality
        document.getElementById('search-box').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            if (searchTerm.length >= 2) {
                searchNodes(searchTerm);
            }
        });

        // Function to search nodes
        async function searchNodes(searchTerm) {
            try {
                const response = await fetch(`${baseUrl}/api/filter?search=${searchTerm}`);
                const data = await response.json();
                if (response.ok) {
                    nodes = data.nodes;
                    links = data.links;
                    updateGraph();
                }
            } catch (error) {
                console.error('Search error:', error);
            }
        }

        // Function to update filters
        function updateFilters() {
            const nodeTypesParam = [...activeFilters.nodeTypes].join(',');
            const relationshipsParam = [...activeFilters.relationships].join(',');
            
            filterNodes(nodeTypesParam, relationshipsParam);
        }

        // Function to filter nodes
        async function filterNodes(labels, relationships) {
            try {
                const params = new URLSearchParams();
                if (labels) params.append('label', labels);
                if (relationships) params.append('relationship', relationships);
                
                const response = await fetch(`${baseUrl}/api/filter?${params}`);
                const data = await response.json();
                
                if (response.ok) {
                    nodes = data.nodes;
                    links = data.links;
                    updateGraph();
                } else {
                    console.error('Error:', data.error);
                }
            } catch (error) {
                console.error('Fetch error:', error);
            }
        }

        // Initialize the visualization
        initializeFilters();
        updateGraph();
    </script>
</body>
</html>