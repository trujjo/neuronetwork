<!DOCTYPE html>
<html>
<head>
    <title>Neo4j Force Graph</title>
    <script src="https://unpkg.com/neo4j-driver@5.15.0"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        body { 
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
        }
        #graph {
            width: 100%;
            height: 800px;
            background-color: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .button {
            padding: 10px 20px;
            background-color: #cc5500;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .button:hover {
            background-color: #ff6a00;
        }
        .node-label {
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            fill: white;
        }
        .link {
            stroke: #808080;
            stroke-opacity: 0.6;
        }
        .link-label {
            font-size: 10px;
            fill: #cccccc;
        }
        .form-control {
            padding: 8px 12px;
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #404040;
            border-radius: 4px;
            margin-bottom: 20px;
            width: 300px;
            font-size: 14px;
        }
        .form-control::placeholder {
            color: #808080;
        }
        .form-control:focus {
            outline: none;
            border-color: #cc5500;
        }
    </style>
</head>
<body>
    <!-- Search input -->
    <input type="text" id="search-input" class="form-control" placeholder="Search nodes...">
    
    <button class="button" onclick="showRandomNodesWithRelationships()">Show Random Connected Nodes</button>
    <div id="status">Ready to connect...</div>
    <div id="graph"></div>

    <script>
        let driver;
        let network; // Define network variable globally
        
        async function initDriver() {
            try {
                driver = neo4j.driver(
                    "neo4j+s://4e5eeae5.databases.neo4j.io:7687",
                    neo4j.auth.basic("neo4j", "Poconoco16!")
                );
                
                // Test the connection
                const session = driver.session();
                await session.run("RETURN 1");
                await session.close();
                
                document.getElementById('status').style.backgroundColor = "#004400";
                document.getElementById('status').textContent = "Connected to Neo4j!";
                
                // Initialize the visualization
                await showRandomNodesWithRelationships();
            } catch (error) {
                console.error(error);
                document.getElementById('status').style.backgroundColor = "#440000";
                document.getElementById('status').textContent = "Failed to connect: " + error;
            }
        }

        async function showRandomNodesWithRelationships() {
            if (!driver) return;
            
            const session = driver.session();
            try {
                const result = await session.run(`
                    MATCH (n)-[r]-(m)
                    WITH n, r, m, rand() as random
                    ORDER BY random
                    LIMIT 50
                    RETURN collect(DISTINCT n) as nodes, collect(DISTINCT r) as rels, collect(DISTINCT m) as connected
                `);
                
                const record = result.records[0];
                const nodes = record.get('nodes');
                const relationships = record.get('rels');
                const connectedNodes = record.get('connected');
                
                // Combine all nodes
                const allNodes = [...nodes, ...connectedNodes];
                
                // Create D3 force simulation
                const width = document.getElementById('graph').clientWidth;
                const height = document.getElementById('graph').clientHeight;
                
                const svg = d3.select("#graph")
                    .html("") // Clear previous content
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                // Create arrow marker
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "-0 -5 10 10")
                    .attr("refX", 20)
                    .attr("refY", 0)
                    .attr("orient", "auto")
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("xoverflow", "visible")
                    .append("svg:path")
                    .attr("d", "M 0,-5 L 10 ,0 L 0,5")
                    .attr("fill", "#808080")
                    .style("stroke", "none");
                
                const simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(d => d.identity.low))
                    .force("charge", d3.forceManyBody().strength(-1000))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(50));
                
                // Create links
                const link = svg.append("g")
                    .selectAll("line")
                    .data(relationships)
                    .enter().append("line")
                    .attr("class", "link")
                    .attr("marker-end", "url(#arrowhead)");
                
                // Add relationship labels
                const linkLabel = svg.append("g")
                    .selectAll("text")
                    .data(relationships)
                    .enter().append("text")
                    .attr("class", "link-label")
                    .text(d => d.type);
                
                // Create nodes
                const node = svg.append("g")
                    .selectAll("g")
                    .data(allNodes)
                    .enter().append("g");
                
                // Add circles for nodes
                node.append("circle")
                    .attr("r", 20)
                    .style("fill", d => {
                        const label = d.labels[0];
                        // Generate a color based on the label
                        let hash = 0;
                        for (let i = 0; i < label.length; i++) {
                            hash = label.charCodeAt(i) + ((hash << 5) - hash);
                        }
                        const hue = hash % 360;
                        return `hsl(${hue}, 70%, 50%)`;
                    });
                
                // Add labels for nodes
                node.append("text")
                    .attr("class", "node-label")
                    .attr("dy", 30)
                    .text(d => {
                        const props = d.properties;
                        return props.name || props.title || d.labels[0];
                    })
                    .each(function(d) {
                        const text = d3.select(this);
                        const words = text.text().split(/\s+/);
                        text.text('');
                        
                        const lineHeight = 1.1;
                        const dy = parseFloat(text.attr("dy"));
                        let line = [];
                        let lineNumber = 0;
                        let tspan = text.append("tspan").attr("x", 0).attr("y", 0).attr("dy", dy + "px");
                        
                        words.forEach(word => {
                            line.push(word);
                            tspan.text(line.join(" "));
                            if (tspan.node().getComputedTextLength() > 50) {
                                line.pop();
                                tspan.text(line.join(" "));
                                line = [word];
                                tspan = text.append("tspan").attr("x", 0).attr("y", 0).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                            }
                        });
                    });
            
                // Add drag behavior
                node.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
                
                // Update positions on each tick
                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);
                    
                    linkLabel
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);
                    
                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                // Set up the simulation
                simulation.nodes(allNodes);
                simulation.force("link").links(relationships);
                
                // Store network data globally
                network = {
                    simulation: simulation,
                    svg: svg,
                    nodes: node,
                    links: link,
                    linkLabels: linkLabel
                };
                
            } catch (error) {
                console.error(error);
                document.getElementById('status').style.backgroundColor = "#440000";
                document.getElementById('status').textContent = "Error loading graph: " + error;
            } finally {
                await session.close();
            }
        }
        
        // Drag functions
        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }
        
        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Search functionality
        let searchTimeout;
        const searchInput = document.getElementById('search-input');

        searchInput.addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            // Clear previous timeout
            clearTimeout(searchTimeout);
            
            // Only search if 3 or more characters are entered
            if (query.length >= 3) {
                searchTimeout = setTimeout(() => {
                    fetch(`/search?q=${encodeURIComponent(query)}`)
                        .then(response => response.json())
                        .then(data => {
                            // Update visualization with search results
                            updateVisualization(data.nodes, data.relationships);
                        })
                        .catch(error => console.error('Error:', error));
                }, 300); // 300ms delay to prevent too many requests
            } else if (query.length === 0) {
                // If search is cleared, show all nodes
                showRandomNodesWithRelationships();
            }
        });

        // Function to update visualization with new data
        function updateVisualization(nodes, relationships) {
            if (!network) return;
            
            // Clear existing visualization
            network.svg.selectAll("*").remove();
            
            // Create new visualization with filtered data
            const simulation = network.simulation;
            simulation.nodes(nodes);
            simulation.force("link").links(relationships);
            
            // Recreate visualization elements...
            // (Add the same visualization code as in showRandomNodesWithRelationships,
            // but using the filtered nodes and relationships instead)
        }

        // Initialize the driver when the page loads
        document.addEventListener('DOMContentLoaded', initDriver);

        // Clean up when the page is closed
        window.onbeforeunload = () => {
            if (driver) {
                driver.close();
            }
        };
    </script>
</body>
</html>
